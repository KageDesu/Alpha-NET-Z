// Generated by CoffeeScript 2.3.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Interpreter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  // * Используется Virtual Interpreter. Команда от сервера запускается в отдельном Interpreter, а не
  // * в аналогичном событии (как это было в Alpha NET).
  // * Некоторы команды выполняются напрямую, а некоторые через общие события только с одной командой

  //@[DEFINES]
  _ = Game_Interpreter.prototype;
  // * Отключение не подходящих для сети комманд
  _.nDisableNotNetCommands = function() {
    var code, disableCommand, i, len, ref;
    disableCommand = function() {
      return _["command" + code] = function() {
        return true;
      };
    };
    ref = [129, 202, 206, 216, 217, 137];
    // * Change Party Member
    // * Set Vehicle Location
    // * Get on/off Vehicle
    // * Change Player Followers
    // * Gather Followers
    // * Change Formation Access
    for (i = 0, len = ref.length; i < len; i++) {
      code = ref[i];
      disableCommand(code);
    }
  };
  _.nIsHaveCommandOptions = function() {
    return this._nCommandOptionsRequested === true && (this.nCommandStartOptions != null);
  };
  _.nClearCommandOptions = function() {
    this._nCommandOptionsRequested = false;
    return this.nCommandStartOptions = null;
  };
  // * Устанавливаем опции (набор данных) и флаг что надо использовать на следующей команде
  _.nSetCommandOptions = function(nCommandStartOptions) {
    this.nCommandStartOptions = nCommandStartOptions;
    return this._nCommandOptionsRequested = true;
  };
  // * Опции подходят для "текущей" (следующей на выполнение) команды
  _.nIsOptionsForCurrentCommand = function() {
    if (!this.nIsHaveCommandOptions()) {
      return false;
    }
    if (ANET.System.ForbiddenVirtualCommandsList.contains(this.currentCommand().code)) {
      return false;
    }
    return true;
  };
  // * Проверка опций и выполнение команды в соответсвии с ними
  _.nProcessCommandWithOptions = function() {
    var e;
    try {
      // * Снимаем флаг, что надо использовать опции
      this._nCommandOptionsRequested = false;
      switch (this.nCommandStartOptions.whoSelector) {
        case "All":
          return this._nProcessCommandForAll();
        case "Master":
          return this._nProcessCommandForMaster(true);
        case "Master Except":
          return this._nProcessCommandForMaster(false);
        case "Actor List":
          return this._nProcessCommandForActorsList(true);
        case "Actor List Except":
          return this._nProcessCommandForActorsList(false);
        case "Me Except":
          return this._nProcessCommandNotMe();
      }
    } catch (error) {
      e = error;
      ANET.w(e);
    }
    return _.ALIAS__executeCommand.call(this);
  };
  _._nProcessCommandForAll = function() {
    this._nSendCommandToServer();
    // * Выполнение команды как обычно у себя (так как там broadcast)
    return _.ALIAS__executeCommand.call(this);
  };
  _._nProcessCommandForMaster = function(isInclude) {
    if (ANNetwork.isMasterClient() === isInclude) {
      return _.ALIAS__executeCommand.call(this);
    } else {
      this._nSendCommandToServer();
      return this._nSkipCommand();
    }
  };
  _._nProcessCommandForActorsList = function(isInclude) {
    this._nSendCommandToServer();
    if (ANET.Utils.isMyActorInValidListToStart(this.nCommandStartOptions.actorList, isInclude)) {
      return _.ALIAS__executeCommand.call(this);
    } else {
      return this._nSkipCommand();
    }
  };
  _._nProcessCommandNotMe = function() {
    this._nSendCommandToServer();
    return this._nSkipCommand();
  };
  _._nSkipCommand = function() {
    this._index++;
    this.nClearCommandOptions();
    return true;
  };
  _._nSendCommandToServer = function() {
    ANInterpreterManager.sendEventVirtualCommand(this.currentCommand(), this.nCommandStartOptions, this.eventId());
  };
  // * Проверить комментарий на наличие NET команд
  _._nCheckNetComment = function(commentLine) {
    var command;
    command = ANET.Utils.getNetCommentCommand(commentLine);
    if (!String.any(command)) {
      return;
    }
    switch (command) {
      case "localActor":
        this._nOnNetCommand_LocalActor(commentLine);
        break;
      case "all":
        this._nOnNetCommand_SingleSelectorEventCommand("All", commentLine);
        break;
      case "!me":
        this._nOnNetCommand_SingleSelectorEventCommand("Me Except", commentLine);
        break;
      case "master":
        this._nOnNetCommand_SingleSelectorEventCommand("Master", commentLine);
        break;
      case "!master":
        this._nOnNetCommand_SingleSelectorEventCommand("Master Except", commentLine);
        break;
      case "forActors":
        this._nOnNetCommand_ActorListSelectorEventCommand(commentLine, true);
        break;
      case "!forActors":
        this._nOnNetCommand_ActorListSelectorEventCommand(commentLine, false);
        break;
      default:
        console.warn("Unknown NET Comment command " + command);
    }
  };
  // * Установить флаг ожидания сервера
  //#_.nSetWaitServer = -> @_waitMode = "netServer"

  // * Ожидание ответа от сервера
  /*_.nUpdateWaitServerResponse = ->
  waiting = ANNetwork.isBusy()
  unless waiting
      @_waitMode = ''
  return waiting*/
  // * Сделать следующую битву сетевой битвой (общей, расшаринной)
  _.nSetSharedBattle = function(battleId) {
    if (!String.any(battleId)) {
      // * Если пустая строка, то Null
      battleId = null;
    }
    BattleManager.nSetNetworkBattle(battleId);
  };
  // * Сбросить все сетевые флаги \ настройки перед запуском очередного события
  _.nClearFlags = function() {
    $gameTemp._nLocalActorMode = false;
    this._nRunningCheckTimer = 0;
    this.nClearCommandOptions();
  };
  (function() {    // * Опции запуска события
    // -----------------------------------------------------------------------
    _.isHaveNetworkStartOptions = function() {
      return this.nStartOptions != null;
    };
    // * Может ли данный игрок запустить это событие
    _.isPassStartOptions = function() {
      if (!this.isHaveNetworkStartOptions()) {
        return true;
      }
      if (this.nIsLockedEvent()) {
        if (ANET.Utils.isEventStartedByAny(this.eventId())) {
          return false;
        }
      }
      return ANET.Utils.isPassEventFilterOptions(this.nStartOptions);
    };
    // * Закрытыми могут быть только события с собственным ID (т.е. события карты)
    // TODO: Общие события не могут быть закрытыми??? МОГУТ! но запускать по другому без проверки на Lock
    _.nIsLockedEvent = function() {
      var ref;
      return this.eventId() > 0 && ((ref = this.nStartOptions) != null ? ref.lockMode : void 0) === "true";
    };
    _.nIsSharedEvent = function() {
      var ref;
      return ((ref = this.nStartOptions) != null ? ref.sharedMode : void 0) !== "NO";
    };
    // * Есть ли опции (условия) запуска события для сети
    return _.nCheckEventStartOptions = function() {
      var e, options, ref;
      this.nStartOptions = null; // * сбрасываем
      try {
        options = (ref = this._list) != null ? ref.find(function(line) {
          var ref1;
          return line.code === 357 && ((ref1 = line.parameters) != null ? ref1[1] : void 0) === "EventStartOptions";
        }) : void 0;
        if (options != null) {
          this.nStartOptions = options.parameters[3];
        }
      } catch (error) {
        e = error;
        ANET.w(e);
        this.nStartOptions = null;
      }
    };
  })();
})();

// ■ END Game_Interpreter.coffee
//---------------------------------------------------------------------------
